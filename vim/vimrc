" Load in all of the Plugin
call plug#begin()
Plug 'jalvesaq/Nvim-R', {'branch': 'stable'}
Plug 'jalvesaq/R-Vim-runtime'
Plug 'madox2/vim-ai'
Plug 'chrisbra/csv.vim' 
Plug 'luochen1990/rainbow'
Plug 'vim-pandoc/vim-rmarkdown'
Plug 'vim-pandoc/vim-pandoc' 
Plug 'vim-pandoc/vim-pandoc-syntax' 
Plug 'jpalardy/vim-slime' 
Plug 'catppuccin/vim', { 'as': 'catppuccin' }
Plug 'itchyny/lightline.vim' 
Plug 'pantharshit00/vim-prisma'
Plug 'neoclide/coc.nvim', {'branch': 'release'} 
Plug 'preservim/nerdtree' 
Plug 'tpope/vim-fugitive' 
Plug 'airblade/vim-gitgutter' 
Plug 'Xuyuanp/nerdtree-git-plugin' 
Plug 'preservim/tagbar'
Plug 'junegunn/fzf.vim'
Plug 'itchyny/vim-qfedit'
Plug 'Yggdroot/indentLine'
call plug#end()

" Set the global extentions
let g:coc_global_extensions = [   'coc-json', 'coc-pyright', 'coc-tabnine', 'coc-prisma', 'coc-r-lsp', 'coc-sh', 'coc-sqlfluff', 'coc-yaml', 'coc-snippets' ,  'coc-tsserver', 'coc-highlight', 'coc-prettier', 'coc-pairs']

" Don't start focused on nerdtree
let g:NERDTreeGitStatusUseNerdFonts = 0 " you should install nerdfonts by yourself. default: 0
let g:NERDTreeGitStatusShowIgnored = 1 " a heavy feature may cost much more time. default: 0

let NERDTreeCustomOpenArgs = {'file':{'where': 'v', 'reuse':'all', 'keepopen':0}}
" Remap nerdtree opens to v and h
let NERDTreeMapOpenVSplit='v'
let NERDTreeMapOpenSplit='h'
let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1
" Special fuzzy find in nerdtree
autocmd FileType nerdtree  noremap <buffer> / :call OpenFzf()<CR>


function! OpenFzf()
    NERDTree
    let job = term_start('/bin/sh -c "fzf"', {'curwin':1, 'out_io': 'file', 'out_name': '/tmp/fzf.file', 'close_cb':'SendFZFtoOpen', 'term_finish':'close'})
endfunction
function! SendFZFtoOpen(channel)
    let l:file_name = readfile('/tmp/fzf.file')[0]    
    execute 'vs ' . l:file_name
endfunction


" Long fix for having two different states for inside and outside working tree
silent! !git rev-parse --is-inside-work-tree
if v:shell_error == 0
	let g:gitgutter_async=0
	let g:gitgutter_max_signs = -1


	let g:lightline = {
          \ 'colorscheme': 'catppuccin_macchiato',
	      \ 'active': {
	      \   'left': [ [ 'mode', 'paste' ],
	      \             [ 'gitbranch', 'gitstatus', 'readonly', 'filename', 'modified' ] ]
	      \ },
	      \ 'component_function': {
	      \   'gitbranch': 'FugitiveHead',
          \   'gitstatus': 'GitStatus'
	      \ },
	      \ }

	function! GitStatus()
	  let [a,m,r] = GitGutterGetHunkSummary()
	  return printf('+%d ~%d -%d', a, m, r)
	endfunction

else
	let g:lightline = {
                \ 'colorscheme': 'catppuccin_macchiato',
	      \ 'active': {
	      \   'left': [ [ 'mode', 'paste' ],
	      \             ['readonly', 'filename', 'modified' ] ]
	      \ },
	      \ }

endif


"lightline
if !has('gui_running')
	  set t_Co=256
endif
set laststatus=2


"Markdown
" Let the rmd hander function! on files ending with .md
au BufRead,BufNewFile *.md  set filetype=rmarkdown
au BufRead,BufNewFile *.rmd  set filetype=rmarkdown
filetype plugin on



" Just how I like my vim, standard formatting
set nocompatible
set ruler
set visualbell
set autoindent
set splitbelow
set splitright
set expandtab
set shiftwidth=4
set tabstop=4
set linebreak
set nospell
set nowrap
set belloff=all
syntax on
set background=dark
set signcolumn=yes
set number
highlight clear SignColumn
set incsearch
set nohidden
set switchbuf=vsplit


" Slime
let g:slime_target = 'vimterminal'
" Shebang stuff
autocmd VimEnter,BufEnter,FocusGained,WinEnter * let g:slime_vimterminal_cmd = getline(1) =~ '\v^#!\s*\zs.*' ? matchstr(getline(1), '\v^#!\s*\zs.*') : '/usr/bin/bash'

" Terminal Things
" function! for opening terminal
function! OpenTerm()
    "  Get command
    let l:term_command = g:slime_vimterminal_cmd
    
    "Open Term in a new split 
    call term_start(l:term_command,{'term_finish':'close', 'term_kill':'term'})

    " Set the format
    set ft=terminal
    setlocal winfixheight
    let l:term_buf_no = winbufnr(0)  
    resize 24

    " Jump back to the og window
    wincmd p
    let b:slime_config = {"bufnr": l:term_buf_no}
endfunction

nnoremap t :call OpenTerm()<CR>
tnoremap <Esc><Esc> <C-w>N


" Navigation around windows is now ctrl with arrow 
nnoremap <c-h> <c-w>h
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-l> <c-w>l
tnoremap <c-h> <Cmd>wincmd h<CR>
tnoremap <c-j> <Cmd>wincmd j<CR>
tnoremap <c-k> <Cmd>wincmd k<CR>
tnoremap <c-l> <Cmd>wincmd l<CR>


nnoremap = :horizontal wincmd =<CR>
nnoremap + :only<CR>


function! MoveRight()
    let l:exempt_ft = ['terminal','nerdtree','tagbar','fugitive','gitcommit','qf']
    let l:left_bar_ft = ['nerdtree','tagbar']
    if index(l:exempt_ft, &filetype) == -1
        execute " wincmd L"
        execute " vertical wincmd = "
    endif
    " If it is a left bar element move the element to the left
    if index(l:left_bar_ft, &filetype) >= 0
        execute " wincmd H"
        execute " wincmd t"
        execute " vertical resize 32"
        setlocal winfixwidth
    endif
    if &filetype=='qf'
        execute " wincmd H"
        execute " vertical resize 32"
        setlocal winfixwidth
    endif
    execute " vertical wincmd = "
endfunction

autocmd FileType  * call MoveRight()

" Easier Nav of buffers
nnoremap bv :vnew<CR>:wincmd L<CR>

nnoremap bh :new<CR>


"Relative Numbers
augroup numbertoggle
  autocmd!
  autocmd BufEnter,FocusGained,InsertLeave,WinEnter * if &nu && mode() != "i" | set rnu   | endif
  autocmd BufLeave,FocusLost,InsertEnter,WinLeave   * if &nu                  | set nornu | endif
augroup END

"COC
" Set internal encoding of vim, not needed on neovim, since coc.nvim using
" unicode characters in the file autoload/float.vim
set encoding=utf-8

" Some servers have issues with backup files, see #649.
set nobackup
set nowritebackup

" Give more space for displaying messages.
set cmdheight=1

" Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
" delays and poor user experience.
set updatetime=100

" Don't pass messages to |ins-completion-menu|.
set shortmess+=c

" Use tab for trigger completion with characters ahead and navigate.
" NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" other plugin before putting this into your config.
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"


function! CheckBackspace() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm(): "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"


" GoTo code navigation.
nmap <silent> gd <Plug>(coc-definition)
nmap q :call LeftBarToQF()<cr>
nmap Q :call AddCursorToQuickfix()<cr>

function! AddCursorToQuickfix()
  " Get the current cursor position
  let cursor_position = getpos('.')
  let line_number = cursor_position[1]
  let column_number = cursor_position[2]
  
  " Get the text of the line at the current cursor position
  let line_text = getline(line_number)

  " Prompt the user for a name/text to associate with the quickfix entry
  let name = input('Enter a name for the quickfix entry: ')

  " Use the user-provided name or fallback to the line's text if left blank
  let text_for_quickfix = (len(name) > 0) ? name : line_text
  
  " Create the new quickfix item with the cursor location and input text
  let quickfix_item = {
        \ 'filename': expand('%'),
        \ 'lnum': line_number,
        \ 'col': column_number,
        \ 'text': text_for_quickfix,
        \ }
  
  " Add the quickfix item to the quickfix list
  call setqflist([quickfix_item], 'a')
endfunction

" Highlight the symbol and its references when holding the cursor.
autocmd CursorHold * silent call CocActionAsync('highlight')



" Jump to the next issue
map <C-n> :call CocAction('diagnosticNext')<cr>
map <C-p> :call CocAction('diagnosticPrevious')<cr>

" Add (Neo)Vim's native statusline support.
" NOTE: Please see `:h coc-status` for integrations with external plugins that
" provide custom statusline: lightline.vim, vim-airline.
set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}


" TAGBAR
let g:tagbar_position = 'topleft vertical'
let g:tagbar_width = 32

" Color stuff
let g:indentLine_setColors = 1
let g:indentLine_char = '‚ñè'
set t_Co=256
set termguicolors
silent! colorscheme catppuccin_macchiato
let g:rainbow_active = 1
" Color for the terminal
let g:terminal_ansi_colors = ["#45475A", "#F38BA8", "#A6E3A1", "#F9E2AF", "#89B4FA", "#F5C2E7", "#94E2D5", "#BAC2DE", "#585B70", "#F38BA8", "#A6E3A1", "#F9E2AF", "#89B4FA", "#F5C2E7", "#94E2D5", "#A6ADC8"]
" Color for git GitGutter
highlight GitGutterAdd    guifg=#89B4FA guibg=NONE
highlight GitGutterChange guifg=#F9E2AF guibg=NONE
highlight GitGutterDelete guifg=#F38BA8 guibg=NONE


"Init left_bar_state
nnoremap F :call LeftBarToNerdFind() <CR>
nnoremap f :call LeftBarToNerd()<CR>
nnoremap s :call LeftBarToTag()<CR>

function! LeftBarToggle()
    wincmd t
    if (&ft=='nerdtree') || (&ft=='tagbar') || (&ft=='qf')
        close
    endif
    wincmd p
endfunction

function! LeftBarToNerd()
    call LeftBarToggle()
    NERDTreeFocus
endfunction

function! LeftBarToTag()
    call LeftBarToggle()
    TagbarOpen
    wincmd t
endfunction

function! LeftBarToQF()
  call LeftBarToggle()
  copen
endfunction

function! LeftBarToNerdFind()
    call LeftBarToggle()
    NERDTreeFind
endfunction

augroup CursorLine
    au!
    au VimEnter * setlocal cursorline
    au WinEnter * setlocal cursorline
    au BufWinEnter * setlocal cursorline
    au WinLeave * setlocal nocursorline
    set concealcursor = ""
augroup END

" Git Stuff

" Generate a Git commit message 


function! GhIssueCreate()
    bot new /tmp/ghissuecreate.md
    :1,$d 
endfunction
    
autocmd BufWritePost /tmp/ghissuecreate.md :call GhIssueCreateCLI()

function! GhIssueCreateCLI()
    let l:title = system("head -n1 /tmp/ghissuecreate.md | sed 's/^#//' | xargs")
    let l:body = system("sed -e 1,2d /tmp/ghissuecreate.md")
    let l:command = "gh issue create --body \"" . l:body . "\" -t \" " . l:title . "\"" 
    bot call  term_start(l:command,{'term_finish':'close'})
endfunction

function! GhPrCreate()
    bot new /tmp/ghprcreate.md
    :1,$d
    :call GitPrRequestGeneration()
endfunction

autocmd BufWritePost /tmp/ghprcreate.md :call GhPrCreateCLI()

function! GhPrCreateCLI()
    let l:title = system("head -n1 /tmp/ghprcreate.md | sed 's/^#//' | xargs")
    let l:body = system("sed -e 1,2d /tmp/ghprcreate.md")
    let l:command = "gh pr create --body \"" . l:body . "\" -t \" " . l:title . "\"" 
    bot call  term_start(l:command,{'term_finish':'close'})
    wincmd J
endfunction

command! Gc :G commit | call GitCommitMessageFn()
command! Ga :w |  G add % 
command! Gaa :wa |  G add -u .
command! Gp :G push
command! Gf :G fetch | G pull
command! Gl :!tig
command!-nargs=1 Gs :G switch -c <args>

command! Gr : call GhPrCreate()
command! Grl : bot call  term_start('gh  pr list') | set nornu | set nu! 
command!-nargs=1 Grv : bot call  term_start('gh  pr view ' . <args>) | set nornu | set nu! 
command!-nargs=1 Gre : bot call  term_start('gh  pr edit ' . <args>,{'term_finish':'close'}) | set nornu | set nu! 
command!-nargs=1 Grm : bot call  term_start('gh  pr merge ' . <args>) | set nornu | set nu! 
command!-nargs=1 Grc : bot call  term_start('gh  pr checkout ' . <args>, {'term_finish':'close'}) | set nornu | set nu! 
command!-nargs=? Grr : bot call  term_start('gh  pr review ' . <args>, {'term_finish':'close'}) | set nornu | set nu! 
command!-nargs=? Grd : bot call  term_start('gh  pr close ' . <args>, {'term_finish':'close'}) | set nornu | set nu! 

command! Gi : call GhIssueCreate()
command! Gil : bot call  term_start('gh issue list ') | set nornu | set nu! 
command!-nargs=1 Giv : bot call  term_start('gh issue view ' . <args>) | set nornu | set nu! 
command!-nargs=1 Gie : bot call  term_start('gh issue  edit ' . <args>,{'term_finish':'close'}) | set nornu | set nu! 
command!-nargs=1 Gir : bot call  term_start('gh issue comment ' . <args>, {'term_finish':'close'}) | set nornu | set nu! 
command!-nargs=1 Gic : bot call  term_start('gh issue develop -c ' . <args>, {'term_finish':'close'}) | set nornu | set nu! 
command!-nargs=1 Gid : bot call  term_start('gh issue close ' . <args>, {'term_finish':'close'}) | set nornu | set nu! 
command!-nargs=* Gh : bot call term_start('gh ' . <q-args>) | set nornu | set nu! 

command! -nargs=? Gt call RunGhAct(<f-args>)
command! Gtl : bot call  term_start('gh act --list ') | set nornu | set nu! 
command! Gth : bot call  term_start('gh run view ') | set nornu | set nu!  | wincmd L 
command! Gtw call VieworWatchLatest()

function! RunGhAct(...)
  if a:0 > 0 " Check if there is an argument
    let cmd = 'gh act -j '.a:1
  else
    let cmd = 'gh act'
  endif
  " Start a new terminal session with the command
  call term_start(split(cmd))
  " Set 'nonumber', toggle 'number'
  set nonu
  set nu!
  wincmd L
endfunction

function! VieworWatchLatest()
  let l:branch_name = system('git rev-parse --abbrev-ref HEAD')
  
  " Run the 'gh run list' command and capture the JSON output
  let l:run_info_json = system('gh run list -b '. shellescape(l:branch_name) .' --limit 1 --json status,databaseId')
  
  " Parse the JSON to get the list of runs
  let l:runs = json_decode(l:run_info_json)
  
  " Check that we have at least one run to process
  if !empty(l:runs)
    " Get the first run's (latest) status and databaseId
    let l:latest_run_status = l:runs[0].status
    let l:latest_run_databaseId = l:runs[0].databaseId

    " Determine action based on run status
    if l:latest_run_status != "completed"
      " If in_progress, open a terminal on the right to watch the run
      vert call term_start('gh run watch '. l:latest_run_databaseId)
    else
      " If not in_progress, open a terminal on the right to view the run details
      vert call term_start('gh run view '. l:latest_run_databaseId) 
    endif
    wincmd L

  else
    echo 'No runs found for branch: '. l:branch_name
  endif
endfunction

let g:model = 'gpt-4-1106-preview'
let g:instruct_model = 'gpt-3.5-turbo'

"config for chat
let g:vim_ai_chat = {
\  "ui": {
\    "code_syntax_enabled": 1,
\    "open_chat_command": "rightbelow vnew | set nonu | set nornu | call vim_ai#MakeScratchWindow()",
\    "scratch_buffer_keep_open": 0,
\    "paste_mode": 1, },
\  "options": {
\    "model": g:model,
\    "max_tokens": 0,
\     }
\}
" map  enter to :AIChat when filetype is aichat
autocmd FileType aichat  inoremap <buffer> <C-M> <C-O>:AIChat<CR> | setlocal wrap

let complete_initial_prompt =<< trim END
>>> system

You are a text and code completion engine. 
You will be sent an instruction, which may be followed by a colon and a chunk of text.
You will return code or text that will be directy inserted into a file
If there is no chunk, then your response will be inserted into an empty file. Make sure to inclue a shebang if writing code
If there is a chunk, the your response will be insertred directly below it
Do not give any commentary about the text
If you are returning code, do not place it in code blocks, instead just return the code as plain text
END

let edit_initial_prompt =<< trim END
>>> system

You are a text and code editing engine. 
You will be sent send you an instruction, followed by a colon and then a chunk of text
You will return code or text that will be directy inserted into a file
Your response will be directy insersted in place of the chunk you have been sent
Do not give any commentary about the text
If you are returning code, do not place it in code blocks, instead just return the code as plain text
END

let g:vim_ai_complete = {
\  "engine": "chat",
\  "options": {
\    "model": g:instruct_model,
\    "endpoint_url": "https://api.openai.com/v1/chat/completions",
\    "max_tokens":0 ,
\    "temperature": 0.2,
\    "request_timeout": 20,
\    "selection_boundary": "",
\    "initial_prompt": complete_initial_prompt,
\  },
\}


let g:vim_ai_edit = {
\  "engine": "chat",
\  "options": {
\    "model": g:instruct_model,
\    "endpoint_url": "https://api.openai.com/v1/chat/completions",
\    "max_tokens":0 ,
\    "temperature": 0.2,
\    "request_timeout": 20,
\    "selection_boundary": "",
\    "initial_prompt": edit_initial_prompt,
\  },
\}

function! GitCommitMessageFn()
  let l:diff = system('git --no-pager diff --staged')
  let l:prompt = "generate a short commit message from the diff below with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description where each sentence is on a new line and it less than 72 characters long, do not use ``` at all in the commit message:\n" . l:diff
  let l:range = 0
  let l:config = {
    \ "engine": "chat",
    \ "options": {
      \ "model": g:model,
      \ "endpoint_url": "https://api.openai.com/v1/chat/completions",
\    "max_tokens": 0,
      \ "temperature": 1,
      \ "request_timeout": 20,
      \ "enable_auth": 1,
      \ "selection_boundary": "",
      \ "initial_prompt": ">>> system \n You are a general assistant. ,If you attach a code block add syntax type after ``` to enable syntax highlighting. "
    \ },
  \ }
  call vim_ai#AIRun(l:range, l:config, l:prompt)
endfunction


function! GitPrRequestGeneration()
  let l:log = system('git log --pretty=%s:%b  $(git branch -l main master)..$(git rev-parse --abbrev-ref HEAD)')
  let l:diff = system('git diff $(git branch -l main master)..$(git rev-parse --abbrev-ref HEAD)')
  let l:branch_name = system('git rev-parse --abbrev-ref HEAD')
  let l:prompt = "Generate a message for a pull request in the form of a rmarkdown file  with a descriptive title, an in depth description of what the pull request will acheive, and a summary of changes made, including a list of modified files given the following branch name: \n" . l:branch_name . "git log: \n" . l:log . " and the following git diff \n" . l:diff . "Mimic the following format: \n #(a descritive title) \n\n ##Description \n\n ##Summary of changes \n ### Changed Files. Do not use ``` to encase the overall text"
  let l:range = 0
  let l:config = {
    \ "engine": "chat",
    \ "options": {
      \ "model": g:model,
      \ "endpoint_url": "https://api.openai.com/v1/chat/completions",
      \ "max_tokens": 4000,
      \ "temperature": 1,
      \ "request_timeout": 20,
      \ "enable_auth": 1,
      \ "selection_boundary": "",
      \ "initial_prompt": ">>> system \n You are a general assistant. ,If you attach a code block add syntax type after ``` to enable syntax highlighting. "
    \ },
  \ }
  call vim_ai#AIRun(l:range, l:config, l:prompt)
endfunction
"SOCLI
function! OpenSO(prompt, range, line1, line2)
  let l:command = '/usr/local/bin/socli -iq "' . a:prompt
  let l:command .= ' '
  if a:range
    let l:command .= join(getline(a:line1, a:line2),' ')
  endif
  let l:command .= '"'
  echo l:command
  vnew | call term_start(l:command, {'curwin':1, 'term_finish':'close'})
  
  set ft=StackOverflow
endfunction

command! -range -nargs=* SO call OpenSO(<q-args>, <range>, <line1>, <line2>)


" Ctags
let g:tagbar_type_rmarkdown = {
      \ 'ctagstype': 'RMarkdown',
      \ 'kinds': [
      \   'c:Chapters',
      \   's:Sections',
      \   'S:Subsections',
      \   't:Subsubsections',
      \   'l:Chunks'
      \ ],
      \ 'sro': '""', 
      \ 'kind2scope': {
      \   'c': 'chapter',
      \   's': 'section',
      \   'S': 'subsection',
      \   't': 'subsubsection'
      \ },
      \ 'scope2kind': {
      \   'chapter': 'c',
      \   'section': 's',
      \   'subsection': 'S',
      \   'subsubsection': 't'
      \ },
      \ 'sort': 0,
      \ 'ctagsbin': '/usr/local/bin/ctags'
      \ }

